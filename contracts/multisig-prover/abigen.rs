// ****
// Auto-generated by cainome do not edit.
// ****

#![allow(clippy::all)]
#![allow(warnings)]

/// Simple contract helper for serialization only (no blockchain interaction)
#[derive(Debug, Clone)]
pub struct AxelarGateway {
    pub address: starknet_core::types::Felt,
}
impl AxelarGateway {
    pub fn new(address: starknet_core::types::Felt) -> Self {
        Self { address }
    }
    pub fn set_contract_address(&mut self, address: starknet_core::types::Felt) {
        self.address = address;
    }
}
#[derive(Debug, PartialEq)]
pub struct ContractCall {
    pub destination_chain: starknet_core::types::Felt,
    pub caller: cainome::cairo_serde::ContractAddress,
    pub destination_contract_address: cainome::cairo_serde::ByteArray,
    pub payload_hash: cainome::cairo_serde::U256,
    pub payload: cainome::cairo_serde::ByteArray,
}
impl cainome::cairo_serde::CairoSerde for ContractCall {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += starknet_core::types::Felt::cairo_serialized_size(
                &__rust.destination_chain,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.caller,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.destination_contract_address,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.payload_hash);
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.payload);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out
            .extend(
                starknet_core::types::Felt::cairo_serialize(&__rust.destination_chain),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.caller),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(
                    &__rust.destination_contract_address,
                ),
            );
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.payload_hash));
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.payload));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let destination_chain = starknet_core::types::Felt::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += starknet_core::types::Felt::cairo_serialized_size(&destination_chain);
        let caller = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&caller);
        let destination_contract_address = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &destination_contract_address,
            );
        let payload_hash = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&payload_hash);
        let payload = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&payload);
        Ok(ContractCall {
            destination_chain,
            caller,
            destination_contract_address,
            payload_hash,
            payload,
        })
    }
}
impl ContractCall {
    pub fn event_selector() -> starknet_core::types::Felt {
        starknet_core::utils::get_selector_from_name("ContractCall").unwrap()
    }
    pub fn event_name() -> &'static str {
        "ContractCall"
    }
}
#[derive(Debug, PartialEq)]
pub struct ContractCallOffchainData {
    pub destination_chain: starknet_core::types::Felt,
    pub caller: cainome::cairo_serde::ContractAddress,
    pub destination_contract_address: cainome::cairo_serde::ByteArray,
    pub payload_hash: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for ContractCallOffchainData {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += starknet_core::types::Felt::cairo_serialized_size(
                &__rust.destination_chain,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.caller,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.destination_contract_address,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.payload_hash);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out
            .extend(
                starknet_core::types::Felt::cairo_serialize(&__rust.destination_chain),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.caller),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(
                    &__rust.destination_contract_address,
                ),
            );
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.payload_hash));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let destination_chain = starknet_core::types::Felt::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += starknet_core::types::Felt::cairo_serialized_size(&destination_chain);
        let caller = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&caller);
        let destination_contract_address = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &destination_contract_address,
            );
        let payload_hash = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&payload_hash);
        Ok(ContractCallOffchainData {
            destination_chain,
            caller,
            destination_contract_address,
            payload_hash,
        })
    }
}
impl ContractCallOffchainData {
    pub fn event_selector() -> starknet_core::types::Felt {
        starknet_core::utils::get_selector_from_name("ContractCallOffchainData").unwrap()
    }
    pub fn event_name() -> &'static str {
        "ContractCallOffchainData"
    }
}
#[derive(Debug, PartialEq)]
pub struct Message {
    pub source_chain: cainome::cairo_serde::ByteArray,
    pub message_id: cainome::cairo_serde::ByteArray,
    pub source_address: cainome::cairo_serde::ByteArray,
    pub contract_address: cainome::cairo_serde::ContractAddress,
    pub payload_hash: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for Message {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.source_chain,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.message_id,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.source_address,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.contract_address,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.payload_hash);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.source_chain),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.message_id),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.source_address),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.contract_address,
                ),
            );
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.payload_hash));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let source_chain = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&source_chain);
        let message_id = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&message_id);
        let source_address = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&source_address);
        let contract_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &contract_address,
            );
        let payload_hash = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&payload_hash);
        Ok(Message {
            source_chain,
            message_id,
            source_address,
            contract_address,
            payload_hash,
        })
    }
}
#[derive(Debug, PartialEq)]
pub struct MessageApproved {
    pub command_id: starknet_core::types::Felt,
    pub source_chain: cainome::cairo_serde::ByteArray,
    pub message_id: cainome::cairo_serde::ByteArray,
    pub source_address: cainome::cairo_serde::ByteArray,
    pub contract_address: cainome::cairo_serde::ContractAddress,
    pub payload_hash: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for MessageApproved {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += starknet_core::types::Felt::cairo_serialized_size(&__rust.command_id);
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.source_chain,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.message_id,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.source_address,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.contract_address,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.payload_hash);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out.extend(starknet_core::types::Felt::cairo_serialize(&__rust.command_id));
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.source_chain),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.message_id),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.source_address),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.contract_address,
                ),
            );
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.payload_hash));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let command_id = starknet_core::types::Felt::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += starknet_core::types::Felt::cairo_serialized_size(&command_id);
        let source_chain = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&source_chain);
        let message_id = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&message_id);
        let source_address = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&source_address);
        let contract_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &contract_address,
            );
        let payload_hash = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&payload_hash);
        Ok(MessageApproved {
            command_id,
            source_chain,
            message_id,
            source_address,
            contract_address,
            payload_hash,
        })
    }
}
impl MessageApproved {
    pub fn event_selector() -> starknet_core::types::Felt {
        starknet_core::utils::get_selector_from_name("MessageApproved").unwrap()
    }
    pub fn event_name() -> &'static str {
        "MessageApproved"
    }
}
#[derive(Debug, PartialEq)]
pub struct MessageExecuted {
    pub command_id: starknet_core::types::Felt,
    pub message_id: cainome::cairo_serde::ByteArray,
    pub source_chain: cainome::cairo_serde::ByteArray,
}
impl cainome::cairo_serde::CairoSerde for MessageExecuted {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += starknet_core::types::Felt::cairo_serialized_size(&__rust.command_id);
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.message_id,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.source_chain,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out.extend(starknet_core::types::Felt::cairo_serialize(&__rust.command_id));
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.message_id),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.source_chain),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let command_id = starknet_core::types::Felt::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += starknet_core::types::Felt::cairo_serialized_size(&command_id);
        let message_id = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&message_id);
        let source_chain = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&source_chain);
        Ok(MessageExecuted {
            command_id,
            message_id,
            source_chain,
        })
    }
}
impl MessageExecuted {
    pub fn event_selector() -> starknet_core::types::Felt {
        starknet_core::utils::get_selector_from_name("MessageExecuted").unwrap()
    }
    pub fn event_name() -> &'static str {
        "MessageExecuted"
    }
}
#[derive(Debug, PartialEq)]
pub struct OperatorshipTransferred {
    pub new_operator: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for OperatorshipTransferred {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.new_operator,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.new_operator,
                ),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let new_operator = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &new_operator,
            );
        Ok(OperatorshipTransferred {
            new_operator,
        })
    }
}
impl OperatorshipTransferred {
    pub fn event_selector() -> starknet_core::types::Felt {
        starknet_core::utils::get_selector_from_name("OperatorshipTransferred").unwrap()
    }
    pub fn event_name() -> &'static str {
        "OperatorshipTransferred"
    }
}
#[derive(Debug, PartialEq)]
pub struct OwnershipTransferStarted {
    pub previous_owner: cainome::cairo_serde::ContractAddress,
    pub new_owner: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for OwnershipTransferStarted {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.previous_owner,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.new_owner,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.previous_owner,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.new_owner),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let previous_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &previous_owner,
            );
        let new_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&new_owner);
        Ok(OwnershipTransferStarted {
            previous_owner,
            new_owner,
        })
    }
}
impl OwnershipTransferStarted {
    pub fn event_selector() -> starknet_core::types::Felt {
        starknet_core::utils::get_selector_from_name("OwnershipTransferStarted").unwrap()
    }
    pub fn event_name() -> &'static str {
        "OwnershipTransferStarted"
    }
}
#[derive(Debug, PartialEq)]
pub struct OwnershipTransferred {
    pub previous_owner: cainome::cairo_serde::ContractAddress,
    pub new_owner: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for OwnershipTransferred {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.previous_owner,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.new_owner,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.previous_owner,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.new_owner),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let previous_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &previous_owner,
            );
        let new_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&new_owner);
        Ok(OwnershipTransferred {
            previous_owner,
            new_owner,
        })
    }
}
impl OwnershipTransferred {
    pub fn event_selector() -> starknet_core::types::Felt {
        starknet_core::utils::get_selector_from_name("OwnershipTransferred").unwrap()
    }
    pub fn event_name() -> &'static str {
        "OwnershipTransferred"
    }
}
#[derive(Debug, PartialEq)]
pub struct Proof {
    pub signers: WeightedSigners,
    pub signatures: Vec<StarkSignature>,
}
impl cainome::cairo_serde::CairoSerde for Proof {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += WeightedSigners::cairo_serialized_size(&__rust.signers);
        __size += Vec::<StarkSignature>::cairo_serialized_size(&__rust.signatures);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out.extend(WeightedSigners::cairo_serialize(&__rust.signers));
        __out.extend(Vec::<StarkSignature>::cairo_serialize(&__rust.signatures));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let signers = WeightedSigners::cairo_deserialize(__felts, __offset)?;
        __offset += WeightedSigners::cairo_serialized_size(&signers);
        let signatures = Vec::<StarkSignature>::cairo_deserialize(__felts, __offset)?;
        __offset += Vec::<StarkSignature>::cairo_serialized_size(&signatures);
        Ok(Proof { signers, signatures })
    }
}
#[derive(Debug, PartialEq)]
pub struct SignersRotated {
    pub epoch: starknet_core::types::Felt,
    pub signers_hash: starknet_core::types::Felt,
    pub signers: WeightedSigners,
}
impl cainome::cairo_serde::CairoSerde for SignersRotated {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += starknet_core::types::Felt::cairo_serialized_size(&__rust.epoch);
        __size
            += starknet_core::types::Felt::cairo_serialized_size(&__rust.signers_hash);
        __size += WeightedSigners::cairo_serialized_size(&__rust.signers);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out.extend(starknet_core::types::Felt::cairo_serialize(&__rust.epoch));
        __out.extend(starknet_core::types::Felt::cairo_serialize(&__rust.signers_hash));
        __out.extend(WeightedSigners::cairo_serialize(&__rust.signers));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let epoch = starknet_core::types::Felt::cairo_deserialize(__felts, __offset)?;
        __offset += starknet_core::types::Felt::cairo_serialized_size(&epoch);
        let signers_hash = starknet_core::types::Felt::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += starknet_core::types::Felt::cairo_serialized_size(&signers_hash);
        let signers = WeightedSigners::cairo_deserialize(__felts, __offset)?;
        __offset += WeightedSigners::cairo_serialized_size(&signers);
        Ok(SignersRotated {
            epoch,
            signers_hash,
            signers,
        })
    }
}
impl SignersRotated {
    pub fn event_selector() -> starknet_core::types::Felt {
        starknet_core::utils::get_selector_from_name("SignersRotated").unwrap()
    }
    pub fn event_name() -> &'static str {
        "SignersRotated"
    }
}
#[derive(Debug, PartialEq)]
pub struct StarkSignature {
    pub r: starknet_core::types::Felt,
    pub s: starknet_core::types::Felt,
    pub v: bool,
}
impl cainome::cairo_serde::CairoSerde for StarkSignature {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += starknet_core::types::Felt::cairo_serialized_size(&__rust.r);
        __size += starknet_core::types::Felt::cairo_serialized_size(&__rust.s);
        __size += bool::cairo_serialized_size(&__rust.v);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out.extend(starknet_core::types::Felt::cairo_serialize(&__rust.r));
        __out.extend(starknet_core::types::Felt::cairo_serialize(&__rust.s));
        __out.extend(bool::cairo_serialize(&__rust.v));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let r = starknet_core::types::Felt::cairo_deserialize(__felts, __offset)?;
        __offset += starknet_core::types::Felt::cairo_serialized_size(&r);
        let s = starknet_core::types::Felt::cairo_deserialize(__felts, __offset)?;
        __offset += starknet_core::types::Felt::cairo_serialized_size(&s);
        let v = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&v);
        Ok(StarkSignature { r, s, v })
    }
}
#[derive(Debug, PartialEq)]
pub struct Upgraded {
    pub class_hash: cainome::cairo_serde::ClassHash,
}
impl cainome::cairo_serde::CairoSerde for Upgraded {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ClassHash::cairo_serialized_size(
                &__rust.class_hash,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ClassHash::cairo_serialize(&__rust.class_hash),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let class_hash = cainome::cairo_serde::ClassHash::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ClassHash::cairo_serialized_size(&class_hash);
        Ok(Upgraded { class_hash })
    }
}
impl Upgraded {
    pub fn event_selector() -> starknet_core::types::Felt {
        starknet_core::utils::get_selector_from_name("Upgraded").unwrap()
    }
    pub fn event_name() -> &'static str {
        "Upgraded"
    }
}
#[derive(Debug, PartialEq)]
pub struct WeightedSigner {
    pub signer: starknet_core::types::Felt,
    #[serde(
        serialize_with = "cainome::cairo_serde::serialize_as_hex",
        deserialize_with = "cainome::cairo_serde::deserialize_from_hex"
    )]
    pub weight: u128,
}
impl cainome::cairo_serde::CairoSerde for WeightedSigner {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += starknet_core::types::Felt::cairo_serialized_size(&__rust.signer);
        __size += u128::cairo_serialized_size(&__rust.weight);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out.extend(starknet_core::types::Felt::cairo_serialize(&__rust.signer));
        __out.extend(u128::cairo_serialize(&__rust.weight));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let signer = starknet_core::types::Felt::cairo_deserialize(__felts, __offset)?;
        __offset += starknet_core::types::Felt::cairo_serialized_size(&signer);
        let weight = u128::cairo_deserialize(__felts, __offset)?;
        __offset += u128::cairo_serialized_size(&weight);
        Ok(WeightedSigner { signer, weight })
    }
}
#[derive(Debug, PartialEq)]
pub struct WeightedSigners {
    pub signers: Vec<WeightedSigner>,
    #[serde(
        serialize_with = "cainome::cairo_serde::serialize_as_hex",
        deserialize_with = "cainome::cairo_serde::deserialize_from_hex"
    )]
    pub threshold: u128,
    pub nonce: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for WeightedSigners {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += Vec::<WeightedSigner>::cairo_serialized_size(&__rust.signers);
        __size += u128::cairo_serialized_size(&__rust.threshold);
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.nonce);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        let mut __out: Vec<starknet_core::types::Felt> = vec![];
        __out.extend(Vec::<WeightedSigner>::cairo_serialize(&__rust.signers));
        __out.extend(u128::cairo_serialize(&__rust.threshold));
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.nonce));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let signers = Vec::<WeightedSigner>::cairo_deserialize(__felts, __offset)?;
        __offset += Vec::<WeightedSigner>::cairo_serialized_size(&signers);
        let threshold = u128::cairo_deserialize(__felts, __offset)?;
        __offset += u128::cairo_serialized_size(&threshold);
        let nonce = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&nonce);
        Ok(WeightedSigners {
            signers,
            threshold,
            nonce,
        })
    }
}
#[derive(Debug, PartialEq)]
pub enum Event {
    Upgraded(Upgraded),
}
impl cainome::cairo_serde::CairoSerde for Event {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            Event::Upgraded(val) => Upgraded::cairo_serialized_size(val) + 1,
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        match __rust {
            Event::Upgraded(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(Upgraded::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(Event::Upgraded(Upgraded::cairo_deserialize(__felts, __offset + 1)?))
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "Event"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<&starknet_core::types::EmittedEvent> for Event {
    type Error = String;
    fn try_from(
        event: &starknet_core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("Upgraded")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Upgraded"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let class_hash = match cainome::cairo_serde::ClassHash::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "class_hash",
                            "Upgraded",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ClassHash::cairo_serialized_size(&class_hash);
            return Ok(Event::Upgraded(Upgraded { class_hash }));
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
impl TryFrom<&starknet_core::types::Event> for Event {
    type Error = String;
    fn try_from(event: &starknet_core::types::Event) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("Upgraded")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Upgraded"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let class_hash = match cainome::cairo_serde::ClassHash::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "class_hash",
                            "Upgraded",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ClassHash::cairo_serialized_size(&class_hash);
            return Ok(Event::Upgraded(Upgraded { class_hash }));
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(Debug, PartialEq)]
pub enum Event {
    MessageApproved(MessageApproved),
    MessageExecuted(MessageExecuted),
    ContractCall(ContractCall),
    ContractCallOffchainData(ContractCallOffchainData),
    OperatorshipTransferred(OperatorshipTransferred),
    AuthWeighted(Event),
    OwnableEvent(Event),
    UpgradeableEvent(Event),
}
impl cainome::cairo_serde::CairoSerde for Event {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            Event::MessageApproved(val) => {
                MessageApproved::cairo_serialized_size(val) + 1
            }
            Event::MessageExecuted(val) => {
                MessageExecuted::cairo_serialized_size(val) + 1
            }
            Event::ContractCall(val) => ContractCall::cairo_serialized_size(val) + 1,
            Event::ContractCallOffchainData(val) => {
                ContractCallOffchainData::cairo_serialized_size(val) + 1
            }
            Event::OperatorshipTransferred(val) => {
                OperatorshipTransferred::cairo_serialized_size(val) + 1
            }
            Event::AuthWeighted(val) => Event::cairo_serialized_size(val) + 1,
            Event::OwnableEvent(val) => Event::cairo_serialized_size(val) + 1,
            Event::UpgradeableEvent(val) => Event::cairo_serialized_size(val) + 1,
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        match __rust {
            Event::MessageApproved(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(MessageApproved::cairo_serialize(val));
                temp
            }
            Event::MessageExecuted(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(MessageExecuted::cairo_serialize(val));
                temp
            }
            Event::ContractCall(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&2usize));
                temp.extend(ContractCall::cairo_serialize(val));
                temp
            }
            Event::ContractCallOffchainData(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&3usize));
                temp.extend(ContractCallOffchainData::cairo_serialize(val));
                temp
            }
            Event::OperatorshipTransferred(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&4usize));
                temp.extend(OperatorshipTransferred::cairo_serialize(val));
                temp
            }
            Event::AuthWeighted(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&5usize));
                temp.extend(Event::cairo_serialize(val));
                temp
            }
            Event::OwnableEvent(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&6usize));
                temp.extend(Event::cairo_serialize(val));
                temp
            }
            Event::UpgradeableEvent(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&7usize));
                temp.extend(Event::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    Event::MessageApproved(
                        MessageApproved::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            1usize => {
                Ok(
                    Event::MessageExecuted(
                        MessageExecuted::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            2usize => {
                Ok(
                    Event::ContractCall(
                        ContractCall::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            3usize => {
                Ok(
                    Event::ContractCallOffchainData(
                        ContractCallOffchainData::cairo_deserialize(
                            __felts,
                            __offset + 1,
                        )?,
                    ),
                )
            }
            4usize => {
                Ok(
                    Event::OperatorshipTransferred(
                        OperatorshipTransferred::cairo_deserialize(
                            __felts,
                            __offset + 1,
                        )?,
                    ),
                )
            }
            5usize => {
                Ok(Event::AuthWeighted(Event::cairo_deserialize(__felts, __offset + 1)?))
            }
            6usize => {
                Ok(Event::OwnableEvent(Event::cairo_deserialize(__felts, __offset + 1)?))
            }
            7usize => {
                Ok(
                    Event::UpgradeableEvent(
                        Event::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "Event"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<&starknet_core::types::EmittedEvent> for Event {
    type Error = String;
    fn try_from(
        event: &starknet_core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("MessageApproved")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "MessageApproved"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let command_id = match starknet_core::types::Felt::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "command_id",
                            "MessageApproved",
                            e,
                        ),
                    );
                }
            };
            key_offset += starknet_core::types::Felt::cairo_serialized_size(&command_id);
            let source_chain = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "source_chain",
                            "MessageApproved",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&source_chain);
            let message_id = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "message_id",
                            "MessageApproved",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&message_id);
            let source_address = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "source_address",
                            "MessageApproved",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                    &source_address,
                );
            let contract_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "contract_address",
                            "MessageApproved",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &contract_address,
                );
            let payload_hash = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "payload_hash",
                            "MessageApproved",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&payload_hash);
            return Ok(
                Event::MessageApproved(MessageApproved {
                    command_id,
                    source_chain,
                    message_id,
                    source_address,
                    contract_address,
                    payload_hash,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("MessageExecuted")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "MessageExecuted"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let command_id = match starknet_core::types::Felt::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "command_id",
                            "MessageExecuted",
                            e,
                        ),
                    );
                }
            };
            key_offset += starknet_core::types::Felt::cairo_serialized_size(&command_id);
            let message_id = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "message_id",
                            "MessageExecuted",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&message_id);
            let source_chain = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "source_chain",
                            "MessageExecuted",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&source_chain);
            return Ok(
                Event::MessageExecuted(MessageExecuted {
                    command_id,
                    message_id,
                    source_chain,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("ContractCall")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "ContractCall"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let destination_chain = match starknet_core::types::Felt::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "destination_chain",
                            "ContractCall",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += starknet_core::types::Felt::cairo_serialized_size(&destination_chain);
            let caller = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "caller",
                            "ContractCall",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&caller);
            let destination_contract_address = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "destination_contract_address",
                            "ContractCall",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                    &destination_contract_address,
                );
            let payload_hash = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "payload_hash",
                            "ContractCall",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&payload_hash);
            let payload = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "payload",
                            "ContractCall",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&payload);
            return Ok(
                Event::ContractCall(ContractCall {
                    destination_chain,
                    caller,
                    destination_contract_address,
                    payload_hash,
                    payload,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("ContractCallOffchainData")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "ContractCallOffchainData")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let destination_chain = match starknet_core::types::Felt::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "destination_chain",
                            "ContractCallOffchainData",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += starknet_core::types::Felt::cairo_serialized_size(&destination_chain);
            let caller = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "caller",
                            "ContractCallOffchainData",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&caller);
            let destination_contract_address = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "destination_contract_address",
                            "ContractCallOffchainData",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                    &destination_contract_address,
                );
            let payload_hash = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "payload_hash",
                            "ContractCallOffchainData",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&payload_hash);
            return Ok(
                Event::ContractCallOffchainData(ContractCallOffchainData {
                    destination_chain,
                    caller,
                    destination_contract_address,
                    payload_hash,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("OperatorshipTransferred")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OperatorshipTransferred")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let new_operator = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "new_operator",
                            "OperatorshipTransferred",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_operator,
                );
            return Ok(
                Event::OperatorshipTransferred(OperatorshipTransferred {
                    new_operator,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("AuthWeighted")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "AuthWeighted"))
        {
            let selector = event.keys[1];
            if selector
                == starknet_core::utils::get_selector_from_name("SignersRotated")
                    .unwrap_or_else(|_| {
                        panic!("Invalid selector for {}", "SignersRotated")
                    })
            {
                let mut key_offset = 1 + 1;
                let mut data_offset = 0;
                let epoch = match starknet_core::types::Felt::cairo_deserialize(
                    &event.keys,
                    key_offset,
                ) {
                    Ok(v) => v,
                    Err(e) => {
                        return Err(
                            format!(
                                "Could not deserialize field {} for {}: {:?}",
                                "epoch",
                                "SignersRotated",
                                e,
                            ),
                        );
                    }
                };
                key_offset += starknet_core::types::Felt::cairo_serialized_size(&epoch);
                let signers_hash = match starknet_core::types::Felt::cairo_deserialize(
                    &event.keys,
                    key_offset,
                ) {
                    Ok(v) => v,
                    Err(e) => {
                        return Err(
                            format!(
                                "Could not deserialize field {} for {}: {:?}",
                                "signers_hash",
                                "SignersRotated",
                                e,
                            ),
                        );
                    }
                };
                key_offset
                    += starknet_core::types::Felt::cairo_serialized_size(&signers_hash);
                let signers = match WeightedSigners::cairo_deserialize(
                    &event.data,
                    data_offset,
                ) {
                    Ok(v) => v,
                    Err(e) => {
                        return Err(
                            format!(
                                "Could not deserialize field {} for {}: {:?}",
                                "signers",
                                "SignersRotated",
                                e,
                            ),
                        );
                    }
                };
                data_offset += WeightedSigners::cairo_serialized_size(&signers);
                return Ok(
                    Event::AuthWeighted(
                        Event::SignersRotated(SignersRotated {
                            epoch,
                            signers_hash,
                            signers,
                        }),
                    ),
                );
            }
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("OwnershipTransferred")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferred")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner",
                            "OwnershipTransferred",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "new_owner",
                            "OwnershipTransferred",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnableEvent(
                    Event::OwnershipTransferred(OwnershipTransferred {
                        previous_owner,
                        new_owner,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("OwnershipTransferStarted")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferStarted")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner",
                            "OwnershipTransferStarted",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "new_owner",
                            "OwnershipTransferStarted",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnableEvent(
                    Event::OwnershipTransferStarted(OwnershipTransferStarted {
                        previous_owner,
                        new_owner,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("Upgraded")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Upgraded"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let class_hash = match cainome::cairo_serde::ClassHash::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "class_hash",
                            "Upgraded",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ClassHash::cairo_serialized_size(&class_hash);
            return Ok(Event::UpgradeableEvent(Event::Upgraded(Upgraded { class_hash })));
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
impl TryFrom<&starknet_core::types::Event> for Event {
    type Error = String;
    fn try_from(event: &starknet_core::types::Event) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("MessageApproved")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "MessageApproved"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let command_id = match starknet_core::types::Felt::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "command_id",
                            "MessageApproved",
                            e,
                        ),
                    );
                }
            };
            key_offset += starknet_core::types::Felt::cairo_serialized_size(&command_id);
            let source_chain = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "source_chain",
                            "MessageApproved",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&source_chain);
            let message_id = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "message_id",
                            "MessageApproved",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&message_id);
            let source_address = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "source_address",
                            "MessageApproved",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                    &source_address,
                );
            let contract_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "contract_address",
                            "MessageApproved",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &contract_address,
                );
            let payload_hash = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "payload_hash",
                            "MessageApproved",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&payload_hash);
            return Ok(
                Event::MessageApproved(MessageApproved {
                    command_id,
                    source_chain,
                    message_id,
                    source_address,
                    contract_address,
                    payload_hash,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("MessageExecuted")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "MessageExecuted"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let command_id = match starknet_core::types::Felt::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "command_id",
                            "MessageExecuted",
                            e,
                        ),
                    );
                }
            };
            key_offset += starknet_core::types::Felt::cairo_serialized_size(&command_id);
            let message_id = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "message_id",
                            "MessageExecuted",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&message_id);
            let source_chain = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "source_chain",
                            "MessageExecuted",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&source_chain);
            return Ok(
                Event::MessageExecuted(MessageExecuted {
                    command_id,
                    message_id,
                    source_chain,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("ContractCall")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "ContractCall"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let destination_chain = match starknet_core::types::Felt::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "destination_chain",
                            "ContractCall",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += starknet_core::types::Felt::cairo_serialized_size(&destination_chain);
            let caller = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "caller",
                            "ContractCall",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&caller);
            let destination_contract_address = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "destination_contract_address",
                            "ContractCall",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                    &destination_contract_address,
                );
            let payload_hash = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "payload_hash",
                            "ContractCall",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&payload_hash);
            let payload = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "payload",
                            "ContractCall",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&payload);
            return Ok(
                Event::ContractCall(ContractCall {
                    destination_chain,
                    caller,
                    destination_contract_address,
                    payload_hash,
                    payload,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("ContractCallOffchainData")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "ContractCallOffchainData")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let destination_chain = match starknet_core::types::Felt::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "destination_chain",
                            "ContractCallOffchainData",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += starknet_core::types::Felt::cairo_serialized_size(&destination_chain);
            let caller = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "caller",
                            "ContractCallOffchainData",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&caller);
            let destination_contract_address = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "destination_contract_address",
                            "ContractCallOffchainData",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                    &destination_contract_address,
                );
            let payload_hash = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "payload_hash",
                            "ContractCallOffchainData",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&payload_hash);
            return Ok(
                Event::ContractCallOffchainData(ContractCallOffchainData {
                    destination_chain,
                    caller,
                    destination_contract_address,
                    payload_hash,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("OperatorshipTransferred")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OperatorshipTransferred")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let new_operator = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "new_operator",
                            "OperatorshipTransferred",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_operator,
                );
            return Ok(
                Event::OperatorshipTransferred(OperatorshipTransferred {
                    new_operator,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("AuthWeighted")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "AuthWeighted"))
        {
            let selector = event.keys[1];
            if selector
                == starknet_core::utils::get_selector_from_name("SignersRotated")
                    .unwrap_or_else(|_| {
                        panic!("Invalid selector for {}", "SignersRotated")
                    })
            {
                let mut key_offset = 1 + 1;
                let mut data_offset = 0;
                let epoch = match starknet_core::types::Felt::cairo_deserialize(
                    &event.keys,
                    key_offset,
                ) {
                    Ok(v) => v,
                    Err(e) => {
                        return Err(
                            format!(
                                "Could not deserialize field {} for {}: {:?}",
                                "epoch",
                                "SignersRotated",
                                e,
                            ),
                        );
                    }
                };
                key_offset += starknet_core::types::Felt::cairo_serialized_size(&epoch);
                let signers_hash = match starknet_core::types::Felt::cairo_deserialize(
                    &event.keys,
                    key_offset,
                ) {
                    Ok(v) => v,
                    Err(e) => {
                        return Err(
                            format!(
                                "Could not deserialize field {} for {}: {:?}",
                                "signers_hash",
                                "SignersRotated",
                                e,
                            ),
                        );
                    }
                };
                key_offset
                    += starknet_core::types::Felt::cairo_serialized_size(&signers_hash);
                let signers = match WeightedSigners::cairo_deserialize(
                    &event.data,
                    data_offset,
                ) {
                    Ok(v) => v,
                    Err(e) => {
                        return Err(
                            format!(
                                "Could not deserialize field {} for {}: {:?}",
                                "signers",
                                "SignersRotated",
                                e,
                            ),
                        );
                    }
                };
                data_offset += WeightedSigners::cairo_serialized_size(&signers);
                return Ok(
                    Event::AuthWeighted(
                        Event::SignersRotated(SignersRotated {
                            epoch,
                            signers_hash,
                            signers,
                        }),
                    ),
                );
            }
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("OwnershipTransferred")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferred")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner",
                            "OwnershipTransferred",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "new_owner",
                            "OwnershipTransferred",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnableEvent(
                    Event::OwnershipTransferred(OwnershipTransferred {
                        previous_owner,
                        new_owner,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("OwnershipTransferStarted")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferStarted")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner",
                            "OwnershipTransferStarted",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "new_owner",
                            "OwnershipTransferStarted",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnableEvent(
                    Event::OwnershipTransferStarted(OwnershipTransferStarted {
                        previous_owner,
                        new_owner,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("Upgraded")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Upgraded"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let class_hash = match cainome::cairo_serde::ClassHash::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "class_hash",
                            "Upgraded",
                            e,
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ClassHash::cairo_serialized_size(&class_hash);
            return Ok(Event::UpgradeableEvent(Event::Upgraded(Upgraded { class_hash })));
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(Debug, PartialEq)]
pub enum Event {
    OwnershipTransferred(OwnershipTransferred),
    OwnershipTransferStarted(OwnershipTransferStarted),
}
impl cainome::cairo_serde::CairoSerde for Event {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            Event::OwnershipTransferred(val) => {
                OwnershipTransferred::cairo_serialized_size(val) + 1
            }
            Event::OwnershipTransferStarted(val) => {
                OwnershipTransferStarted::cairo_serialized_size(val) + 1
            }
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        match __rust {
            Event::OwnershipTransferred(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(OwnershipTransferred::cairo_serialize(val));
                temp
            }
            Event::OwnershipTransferStarted(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(OwnershipTransferStarted::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    Event::OwnershipTransferred(
                        OwnershipTransferred::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            1usize => {
                Ok(
                    Event::OwnershipTransferStarted(
                        OwnershipTransferStarted::cairo_deserialize(
                            __felts,
                            __offset + 1,
                        )?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "Event"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<&starknet_core::types::EmittedEvent> for Event {
    type Error = String;
    fn try_from(
        event: &starknet_core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("OwnershipTransferred")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferred")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner",
                            "OwnershipTransferred",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "new_owner",
                            "OwnershipTransferred",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnershipTransferred(OwnershipTransferred {
                    previous_owner,
                    new_owner,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("OwnershipTransferStarted")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferStarted")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner",
                            "OwnershipTransferStarted",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "new_owner",
                            "OwnershipTransferStarted",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnershipTransferStarted(OwnershipTransferStarted {
                    previous_owner,
                    new_owner,
                }),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
impl TryFrom<&starknet_core::types::Event> for Event {
    type Error = String;
    fn try_from(event: &starknet_core::types::Event) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("OwnershipTransferred")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferred")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner",
                            "OwnershipTransferred",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "new_owner",
                            "OwnershipTransferred",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnershipTransferred(OwnershipTransferred {
                    previous_owner,
                    new_owner,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("OwnershipTransferStarted")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferStarted")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner",
                            "OwnershipTransferStarted",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "new_owner",
                            "OwnershipTransferStarted",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnershipTransferStarted(OwnershipTransferStarted {
                    previous_owner,
                    new_owner,
                }),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(Debug, PartialEq)]
pub enum Event {
    SignersRotated(SignersRotated),
}
impl cainome::cairo_serde::CairoSerde for Event {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            Event::SignersRotated(val) => SignersRotated::cairo_serialized_size(val) + 1,
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet_core::types::Felt> {
        match __rust {
            Event::SignersRotated(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(SignersRotated::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet_core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    Event::SignersRotated(
                        SignersRotated::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "Event"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<&starknet_core::types::EmittedEvent> for Event {
    type Error = String;
    fn try_from(
        event: &starknet_core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("SignersRotated")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "SignersRotated"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let epoch = match starknet_core::types::Felt::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "epoch",
                            "SignersRotated",
                            e,
                        ),
                    );
                }
            };
            key_offset += starknet_core::types::Felt::cairo_serialized_size(&epoch);
            let signers_hash = match starknet_core::types::Felt::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "signers_hash",
                            "SignersRotated",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += starknet_core::types::Felt::cairo_serialized_size(&signers_hash);
            let signers = match WeightedSigners::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "signers",
                            "SignersRotated",
                            e,
                        ),
                    );
                }
            };
            data_offset += WeightedSigners::cairo_serialized_size(&signers);
            return Ok(
                Event::SignersRotated(SignersRotated {
                    epoch,
                    signers_hash,
                    signers,
                }),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
impl TryFrom<&starknet_core::types::Event> for Event {
    type Error = String;
    fn try_from(event: &starknet_core::types::Event) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet_core::utils::get_selector_from_name("SignersRotated")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "SignersRotated"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let epoch = match starknet_core::types::Felt::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "epoch",
                            "SignersRotated",
                            e,
                        ),
                    );
                }
            };
            key_offset += starknet_core::types::Felt::cairo_serialized_size(&epoch);
            let signers_hash = match starknet_core::types::Felt::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "signers_hash",
                            "SignersRotated",
                            e,
                        ),
                    );
                }
            };
            key_offset
                += starknet_core::types::Felt::cairo_serialized_size(&signers_hash);
            let signers = match WeightedSigners::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "signers",
                            "SignersRotated",
                            e,
                        ),
                    );
                }
            };
            data_offset += WeightedSigners::cairo_serialized_size(&signers);
            return Ok(
                Event::SignersRotated(SignersRotated {
                    epoch,
                    signers_hash,
                    signers,
                }),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
impl<A: starknet::accounts::ConnectedAccount + Sync> AxelarGateway<A> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn epoch(&self) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name("epoch")
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn epoch_by_signers_hash(
        &self,
        signers_hash: &starknet_core::types::Felt,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet_core::types::Felt::cairo_serialize(signers_hash));
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "epoch_by_signers_hash",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn is_message_approved(
        &self,
        source_chain: &cainome::cairo_serde::ByteArray,
        message_id: &cainome::cairo_serde::ByteArray,
        source_address: &cainome::cairo_serde::ByteArray,
        contract_address: &cainome::cairo_serde::ContractAddress,
        payload_hash: &cainome::cairo_serde::U256,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(source_chain));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(message_id));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(source_address));
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(contract_address),
            );
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(payload_hash));
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "is_message_approved",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn is_message_executed(
        &self,
        source_chain: &cainome::cairo_serde::ByteArray,
        message_id: &cainome::cairo_serde::ByteArray,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(source_chain));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(message_id));
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "is_message_executed",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn last_rotation_timestamp(&self) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "last_rotation_timestamp",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn operator(&self) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "operator",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn owner(&self) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name("owner")
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn signers_hash_by_epoch(
        &self,
        signer_epoch: &starknet_core::types::Felt,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet_core::types::Felt::cairo_serialize(signer_epoch));
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "signers_hash_by_epoch",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn time_since_rotation(&self) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "time_since_rotation",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn approve_messages_getcall(
        &self,
        messages: &Vec<Message>,
        proof: &Proof,
    ) -> starknet_core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(Vec::<Message>::cairo_serialize(messages));
        __calldata.extend(Proof::cairo_serialize(proof));
        starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("approve_messages")
                .unwrap(),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn approve_messages(
        &self,
        messages: &Vec<Message>,
        proof: &Proof,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(Vec::<Message>::cairo_serialize(messages));
        __calldata.extend(Proof::cairo_serialize(proof));
        let __call = starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("approve_messages")
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn call_contract_getcall(
        &self,
        destination_chain: &starknet_core::types::Felt,
        destination_contract_address: &cainome::cairo_serde::ByteArray,
        payload: &cainome::cairo_serde::ByteArray,
    ) -> starknet_core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(starknet_core::types::Felt::cairo_serialize(destination_chain));
        __calldata
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(
                    destination_contract_address,
                ),
            );
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(payload));
        starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("call_contract")
                .unwrap(),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn call_contract(
        &self,
        destination_chain: &starknet_core::types::Felt,
        destination_contract_address: &cainome::cairo_serde::ByteArray,
        payload: &cainome::cairo_serde::ByteArray,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(starknet_core::types::Felt::cairo_serialize(destination_chain));
        __calldata
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(
                    destination_contract_address,
                ),
            );
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(payload));
        let __call = starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("call_contract")
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn call_contract_offchain_data_getcall(
        &self,
        destination_chain: &starknet_core::types::Felt,
        destination_contract_address: &cainome::cairo_serde::ByteArray,
        payload_hash: &cainome::cairo_serde::U256,
    ) -> starknet_core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(starknet_core::types::Felt::cairo_serialize(destination_chain));
        __calldata
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(
                    destination_contract_address,
                ),
            );
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(payload_hash));
        starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name(
                    "call_contract_offchain_data",
                )
                .unwrap(),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn call_contract_offchain_data(
        &self,
        destination_chain: &starknet_core::types::Felt,
        destination_contract_address: &cainome::cairo_serde::ByteArray,
        payload_hash: &cainome::cairo_serde::U256,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(starknet_core::types::Felt::cairo_serialize(destination_chain));
        __calldata
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(
                    destination_contract_address,
                ),
            );
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(payload_hash));
        let __call = starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name(
                    "call_contract_offchain_data",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn init_signers_getcall(
        &self,
        signers: &Vec<WeightedSigners>,
        operator: &Option<cainome::cairo_serde::ContractAddress>,
    ) -> starknet_core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(Vec::<WeightedSigners>::cairo_serialize(signers));
        __calldata
            .extend(
                Option::<
                    cainome::cairo_serde::ContractAddress,
                >::cairo_serialize(operator),
            );
        starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("init_signers")
                .unwrap(),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn init_signers(
        &self,
        signers: &Vec<WeightedSigners>,
        operator: &Option<cainome::cairo_serde::ContractAddress>,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(Vec::<WeightedSigners>::cairo_serialize(signers));
        __calldata
            .extend(
                Option::<
                    cainome::cairo_serde::ContractAddress,
                >::cairo_serialize(operator),
            );
        let __call = starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("init_signers")
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn renounce_ownership_getcall(&self) -> starknet_core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("renounce_ownership")
                .unwrap(),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn renounce_ownership(&self) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("renounce_ownership")
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn rotate_signers_getcall(
        &self,
        new_signers: &WeightedSigners,
        proof: &Proof,
    ) -> starknet_core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(WeightedSigners::cairo_serialize(new_signers));
        __calldata.extend(Proof::cairo_serialize(proof));
        starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("rotate_signers")
                .unwrap(),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn rotate_signers(
        &self,
        new_signers: &WeightedSigners,
        proof: &Proof,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(WeightedSigners::cairo_serialize(new_signers));
        __calldata.extend(Proof::cairo_serialize(proof));
        let __call = starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("rotate_signers")
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_operatorship_getcall(
        &self,
        new_operator: &cainome::cairo_serde::ContractAddress,
    ) -> starknet_core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(new_operator),
            );
        starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name(
                    "transfer_operatorship",
                )
                .unwrap(),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_operatorship(
        &self,
        new_operator: &cainome::cairo_serde::ContractAddress,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(new_operator),
            );
        let __call = starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name(
                    "transfer_operatorship",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_ownership_getcall(
        &self,
        new_owner: &cainome::cairo_serde::ContractAddress,
    ) -> starknet_core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(new_owner));
        starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("transfer_ownership")
                .unwrap(),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_ownership(
        &self,
        new_owner: &cainome::cairo_serde::ContractAddress,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(new_owner));
        let __call = starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("transfer_ownership")
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn upgrade_getcall(
        &self,
        new_class_hash: &cainome::cairo_serde::ClassHash,
    ) -> starknet_core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ClassHash::cairo_serialize(new_class_hash));
        starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("upgrade").unwrap(),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn upgrade(
        &self,
        new_class_hash: &cainome::cairo_serde::ClassHash,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ClassHash::cairo_serialize(new_class_hash));
        let __call = starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("upgrade").unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn validate_message_getcall(
        &self,
        source_chain: &cainome::cairo_serde::ByteArray,
        message_id: &cainome::cairo_serde::ByteArray,
        source_address: &cainome::cairo_serde::ByteArray,
        payload_hash: &cainome::cairo_serde::U256,
    ) -> starknet_core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(source_chain));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(message_id));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(source_address));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(payload_hash));
        starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("validate_message")
                .unwrap(),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn validate_message(
        &self,
        source_chain: &cainome::cairo_serde::ByteArray,
        message_id: &cainome::cairo_serde::ByteArray,
        source_address: &cainome::cairo_serde::ByteArray,
        payload_hash: &cainome::cairo_serde::U256,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(source_chain));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(message_id));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(source_address));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(payload_hash));
        let __call = starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("validate_message")
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn validate_proof_getcall(
        &self,
        data_hash: &starknet_core::types::Felt,
        proof: &Proof,
    ) -> starknet_core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet_core::types::Felt::cairo_serialize(data_hash));
        __calldata.extend(Proof::cairo_serialize(proof));
        starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("validate_proof")
                .unwrap(),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn validate_proof(
        &self,
        data_hash: &starknet_core::types::Felt,
        proof: &Proof,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet_core::types::Felt::cairo_serialize(data_hash));
        __calldata.extend(Proof::cairo_serialize(proof));
        let __call = starknet_core::types::Call {
            to: self.address,
            selector: starknet_core::utils::get_selector_from_name("validate_proof")
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
}
impl<P: starknet::providers::Provider + Sync> AxelarGatewayReader<P> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn epoch(&self) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name("epoch")
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn epoch_by_signers_hash(
        &self,
        signers_hash: &starknet_core::types::Felt,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet_core::types::Felt::cairo_serialize(signers_hash));
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "epoch_by_signers_hash",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn is_message_approved(
        &self,
        source_chain: &cainome::cairo_serde::ByteArray,
        message_id: &cainome::cairo_serde::ByteArray,
        source_address: &cainome::cairo_serde::ByteArray,
        contract_address: &cainome::cairo_serde::ContractAddress,
        payload_hash: &cainome::cairo_serde::U256,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(source_chain));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(message_id));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(source_address));
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(contract_address),
            );
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(payload_hash));
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "is_message_approved",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn is_message_executed(
        &self,
        source_chain: &cainome::cairo_serde::ByteArray,
        message_id: &cainome::cairo_serde::ByteArray,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(source_chain));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(message_id));
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "is_message_executed",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn last_rotation_timestamp(&self) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "last_rotation_timestamp",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn operator(&self) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "operator",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn owner(&self) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name("owner")
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn signers_hash_by_epoch(
        &self,
        signer_epoch: &starknet_core::types::Felt,
    ) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(starknet_core::types::Felt::cairo_serialize(signer_epoch));
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "signers_hash_by_epoch",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn time_since_rotation(&self) -> Vec<starknet_core::types::Felt> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet_core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet_core::utils::get_selector_from_name(
                    "time_since_rotation",
                )
                .unwrap(),
            calldata: __calldata,
        };
        __calldata
    }
}
